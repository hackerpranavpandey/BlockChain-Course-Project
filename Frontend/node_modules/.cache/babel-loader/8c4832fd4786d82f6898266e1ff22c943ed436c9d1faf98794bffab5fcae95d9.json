{"ast":null,"code":"var _jsxFileName = \"/home/pranav/Documents/Blockchain-Project/Blockchain-Project/Blockchain-Project/t/client/src/components/FileUpload.js\",\n  _s = $RefreshSig$();\nimport { useState } from \"react\";\nimport axios from \"axios\";\nimport \"./FileUpload.css\";\nimport { toast } from \"react-toastify\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst calculateFileHash = async file => {\n  const buffer = await file.arrayBuffer();\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hashHex;\n};\nconst PINATA_API_KEY = \"ae1ba446a9aeca73624c\";\nconst PINATA_SECRET_API_KEY = \"b30349d6044ed59285ba496207015af363c7ad38dcefdca17fa96481b9f9360d\";\nconst CONSENSUS_THRESHOLD = 0.5;\nconst NODE_REQUEST_TIMEOUT = 15000;\nconst DEEPFAKE_NODE_URLS = [\"http://localhost:5001/predict\", \"http://localhost:5002/predict\", \"http://localhost:5003/predict\"];\nconst FileUpload = ({\n  contract,\n  account,\n  provider\n}) => {\n  _s();\n  const [file, setFile] = useState(null);\n  const [fileName, setFileName] = useState(\"No image selected\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [message, setMessage] = useState(\"\");\n  const [imageHash, setImageHash] = useState(\"\");\n  const retrieveFile = e => {\n    const selected = e.target.files[0];\n    if (selected) {\n      setFile(selected);\n      setFileName(selected.name);\n      setMessage(\"\");\n      setImageHash(\"\");\n      toast.success(\"Image/Video file is selected\");\n    } else {\n      setFile(null);\n      setFileName(\"No image selected\");\n      setImageHash(\"\");\n    }\n  };\n  const determineConsensus = results => {\n    if (!results || results.length === 0) {\n      return {\n        consensus: \"inconclusive\",\n        reason: \"No valid responses from nodes.\"\n      };\n    }\n    let realVotes = 0;\n    let fakeVotes = 0;\n    let totalConfidenceReal = 0;\n    let totalConfidenceFake = 0;\n    results.forEach(result => {\n      if (result.is_deepfake === true) {\n        fakeVotes++;\n        totalConfidenceFake += typeof result.confidence === \"number\" ? result.confidence : 0;\n      } else if (result.is_deepfake === false) {\n        realVotes++;\n        totalConfidenceReal += typeof result.confidence === \"number\" ? result.confidence : 0;\n      }\n    });\n    const totalVotes = realVotes + fakeVotes;\n    if (totalVotes === 0) {\n      return {\n        consensus: \"inconclusive\",\n        reason: \"No nodes provided a clear real/fake vote.\"\n      };\n    }\n    const realRatio = realVotes / totalVotes;\n    const fakeRatio = fakeVotes / totalVotes;\n    console.log(`Consensus Check: Real Votes=${realVotes}, Fake Votes=${fakeVotes}, Total Votes=${totalVotes}, totalConfidenceReal=${totalConfidenceReal}, totalConfidenceFake=${totalConfidenceFake}`);\n    if (realRatio > CONSENSUS_THRESHOLD) {\n      const avgConfidence = realVotes > 0 ? totalConfidenceReal / realVotes : 0;\n      return {\n        consensus: \"real\",\n        confidence: avgConfidence,\n        votes: `${realVotes}/${totalVotes}`\n      };\n    } else if (fakeRatio > CONSENSUS_THRESHOLD) {\n      const avgConfidence = fakeVotes > 0 ? totalConfidenceFake / fakeVotes : 0;\n      return {\n        consensus: \"deepfake\",\n        confidence: avgConfidence,\n        votes: `${fakeVotes}/${totalVotes}`\n      };\n    } else {\n      // Handle ties or below-threshold majority\n      return {\n        consensus: \"inconclusive\",\n        reason: `No clear majority (${realVotes} real, ${fakeVotes} fake).`\n      };\n    }\n  };\n  const handleSubmit = async e => {\n    e.preventDefault();\n    if (!file) {\n      setMessage(\"Please select a file first.\");\n      return;\n    }\n    if (!contract || !account) {\n      setMessage(\"Wallet not connected or contract not loaded.\");\n      return;\n    }\n    setIsLoading(true);\n    setMessage(\"Processing image...\");\n    setImageHash(\"\");\n    try {\n      var _consensusOutcome$con2;\n      setMessage(\"Calculating image hash...\");\n      const calculatedHash = await calculateFileHash(file);\n      setImageHash(calculatedHash);\n      console.log(\"Calculated Image Hash:\", calculatedHash);\n      toast.success(\"Calculated Image Hash:\", calculatedHash);\n      setMessage(\"Image hash calculated. Analyzing for deepfakes...\");\n      const deepfakeFormData = new FormData();\n      deepfakeFormData.append(\"image\", file);\n      const promises = DEEPFAKE_NODE_URLS.map(url => {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), NODE_REQUEST_TIMEOUT);\n        return fetch(url, {\n          method: \"POST\",\n          body: deepfakeFormData,\n          // Send the same data\n          signal: controller.signal // Link abort controller\n        }).then(async response => {\n          clearTimeout(timeoutId); // Clear timeout if fetch completes\n          if (!response.ok) {\n            // Try to get error details from response body\n            let errorMsg = `Node request failed: ${response.status}`;\n            try {\n              const errData = await response.json();\n              errorMsg = errData.error || errorMsg;\n            } catch (parseErr) {\n              /* Ignore parsing error */\n            }\n            // Throw an error object compatible with allSettled 'reason'\n            throw new Error(errorMsg);\n          }\n          return response.json(); // Parse successful response\n        }).catch(error => {\n          clearTimeout(timeoutId); // Clear timeout if fetch fails/aborts\n          console.warn(`Node request failed for ${url}: ${error.message}`);\n          // Return a specific structure for failed promises if needed later,\n          // but allSettled captures the reason object anyway.\n          throw error; // Re-throw to be caught by allSettled as 'rejected'\n        });\n      });\n      setMessage(`Sent requests to ${DEEPFAKE_NODE_URLS.length} nodes. Awaiting responses...`);\n      const results = await Promise.allSettled(promises);\n\n      // Process results from nodes that succeeded\n      const successfulResults = [];\n      let nodeErrors = 0;\n      results.forEach((result, index) => {\n        if (result.status === \"fulfilled\") {\n          var _result$value;\n          console.log(`Node ${DEEPFAKE_NODE_URLS[index]} Result:`, result.value);\n          // Basic validation of the result structure\n          if (typeof ((_result$value = result.value) === null || _result$value === void 0 ? void 0 : _result$value.is_deepfake) === \"boolean\") {\n            successfulResults.push(result.value);\n          } else {\n            console.warn(`Node ${DEEPFAKE_NODE_URLS[index]} returned invalid data format.`);\n            nodeErrors++;\n          }\n        } else {\n          var _result$reason;\n          console.error(`Node ${DEEPFAKE_NODE_URLS[index]} Failed:`, ((_result$reason = result.reason) === null || _result$reason === void 0 ? void 0 : _result$reason.message) || result.reason);\n          nodeErrors++;\n        }\n      });\n      setMessage(`Received responses. ${successfulResults.length} successful, ${nodeErrors} failed/invalid. Determining consensus...`);\n\n      // --- Step 3: Determine Consensus Outcome ---\n      const consensusOutcome = determineConsensus(successfulResults);\n      console.log(\"Consensus Outcome:\", consensusOutcome);\n\n      // --- Step 4: Act based on Consensus ---\n      if (consensusOutcome.consensus === \"deepfake\") {\n        var _consensusOutcome$con;\n        setMessage(`‚ö†Ô∏è Consensus: Deepfake Detected (${consensusOutcome.votes} votes, avg conf ${(_consensusOutcome$con = consensusOutcome.confidence) === null || _consensusOutcome$con === void 0 ? void 0 : _consensusOutcome$con.toFixed(4)}). Upload cancelled. Hash: ${calculatedHash.substring(0, 10)}...`);\n        toast.warn(\"DeepFake detected!\");\n        setFile(null);\n        setFileName(\"No image selected\");\n        setIsLoading(false);\n        return;\n      }\n      if (consensusOutcome.consensus === \"inconclusive\") {\n        setMessage(`ü§î Consensus Inconclusive: ${consensusOutcome.reason}. Upload cancelled.`);\n        setFile(null);\n        setFileName(\"No image selected\");\n        setIsLoading(false);\n        return;\n      }\n\n      // --- Step 5: Proceed if Consensus is REAL ---\n      setMessage(`‚úÖ Consensus: Real Image Detected (${consensusOutcome.votes} votes, avg conf ${(_consensusOutcome$con2 = consensusOutcome.confidence) === null || _consensusOutcome$con2 === void 0 ? void 0 : _consensusOutcome$con2.toFixed(4)}). Uploading to IPFS...`);\n      toast.success(\"Real Image Detected!\");\n\n      // --- Step 6: Upload to Pinata (Same as before) ---\n      const pinataFormData = new FormData();\n      pinataFormData.append(\"file\", file);\n      const pinataMetadata = JSON.stringify({\n        name: fileName,\n        keyvalues: {\n          imageHash: calculatedHash\n        }\n      });\n      pinataFormData.append(\"pinataMetadata\", pinataMetadata);\n      const pinataOptions = JSON.stringify({\n        cidVersion: 1\n      });\n      pinataFormData.append(\"pinataOptions\", pinataOptions);\n      const resFile = await axios.post(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", pinataFormData, {\n        headers: {\n          pinata_api_key: PINATA_API_KEY,\n          pinata_secret_api_key: PINATA_SECRET_API_KEY\n        }\n      });\n      const imageCid = resFile.data.IpfsHash;\n      console.log(\"File uploaded to Pinata. CID:\", imageCid);\n      if (!imageCid) throw new Error(\"Failed to get IPFS hash from Pinata response.\");\n      setMessage(`Image uploaded to IPFS (CID: ${imageCid.substring(0, 10)}...). Adding to blockchain...`);\n      toast.success(\"Image Uploaded to Pinata!\");\n\n      // --- Step 7: Add CID and Hash to Blockchain (Same as before) ---\n      console.log(`Calling contract.add(\"${account}\", \"${imageCid}\", \"${calculatedHash}\")`);\n      const transaction = await contract.add(account, imageCid, calculatedHash);\n      setMessage(`Transaction sent (${transaction.hash.substring(0, 10)}...). Waiting for confirmation...`);\n      await transaction.wait();\n      setMessage(`‚úÖ Successfully uploaded. CID and Hash recorded on the blockchain!`);\n      toast.success(\"Successfully uploaded. CID and Hash recorded on the blockchain!\");\n      setFileName(\"No image selected\");\n      setFile(null);\n    } catch (error) {\n      var _error$response, _error$response$data, _error$data;\n      console.error(\"Upload process failed:\", error);\n      toast.error(\"Upload process failed:\", error);\n      // More specific error handling might be needed depending on where the error originated\n      let specificMessage = `Upload failed: ${error.message}`;\n      if (error.message.includes(\"Node request failed\")) {\n        specificMessage = `Node verification error: ${error.message}`;\n      } else if ((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && _error$response$data.error) {\n        specificMessage = `Pinata upload error: ${error.response.data.error}`;\n      } else if (error.code === \"ACTION_REJECTED\") {\n        specificMessage = \"Transaction rejected in MetaMask.\";\n      } else if (error.reason || (_error$data = error.data) !== null && _error$data !== void 0 && _error$data.message) {\n        specificMessage = `Blockchain transaction failed: ${error.reason || error.data.message}`;\n      }\n      setMessage(`‚ùå ${specificMessage}`);\n      // Consider leaving file selected on certain errors to allow retry?\n      // setFile(null); setFileName(\"No image selected\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"top file-upload-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Upload & Authenticate Image\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 334,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      className: \"form\",\n      onSubmit: handleSubmit,\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"file-upload\",\n        className: `choose ${!account || isLoading ? \"disabled\" : \"\"}`,\n        children: file ? \"Change Image\" : \"Choose Image\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 336,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        disabled: !account || isLoading,\n        type: \"file\",\n        accept: \"image/png, image/jpeg, image/jpg\",\n        id: \"file-upload\",\n        name: \"data\",\n        onChange: retrieveFile\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"textArea file-name-display\",\n        children: [\"Image: \", fileName]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 350,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"submit\",\n        className: \"upload\",\n        disabled: !file || isLoading || !account,\n        children: isLoading ? \"Processing...\" : \"Verify & Upload\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 335,\n      columnNumber: 7\n    }, this), message && /*#__PURE__*/_jsxDEV(\"p\", {\n      className: `upload-message ${message.includes(\"Error\") || message.includes(\"‚ö†Ô∏è\") || message.includes(\"‚ùå\") || message.includes(\"ü§î\") ? \"error\" : message.includes(\"‚úÖ\") ? \"success\" : \"info\"}`,\n      children: message\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 360,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 333,\n    columnNumber: 5\n  }, this);\n};\n_s(FileUpload, \"SK761qg68Sgc/nXNA7nH636RVl0=\");\n_c = FileUpload;\nexport default FileUpload;\nvar _c;\n$RefreshReg$(_c, \"FileUpload\");","map":{"version":3,"names":["useState","axios","toast","jsxDEV","_jsxDEV","calculateFileHash","file","buffer","arrayBuffer","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","padStart","join","PINATA_API_KEY","PINATA_SECRET_API_KEY","CONSENSUS_THRESHOLD","NODE_REQUEST_TIMEOUT","DEEPFAKE_NODE_URLS","FileUpload","contract","account","provider","_s","setFile","fileName","setFileName","isLoading","setIsLoading","message","setMessage","imageHash","setImageHash","retrieveFile","e","selected","target","files","name","success","determineConsensus","results","length","consensus","reason","realVotes","fakeVotes","totalConfidenceReal","totalConfidenceFake","forEach","result","is_deepfake","confidence","totalVotes","realRatio","fakeRatio","console","log","avgConfidence","votes","handleSubmit","preventDefault","_consensusOutcome$con2","calculatedHash","deepfakeFormData","FormData","append","promises","url","controller","AbortController","timeoutId","setTimeout","abort","fetch","method","body","signal","then","response","clearTimeout","ok","errorMsg","status","errData","json","error","parseErr","Error","catch","warn","Promise","allSettled","successfulResults","nodeErrors","index","_result$value","value","push","_result$reason","consensusOutcome","_consensusOutcome$con","toFixed","substring","pinataFormData","pinataMetadata","JSON","stringify","keyvalues","pinataOptions","cidVersion","resFile","post","headers","pinata_api_key","pinata_secret_api_key","imageCid","data","IpfsHash","transaction","add","hash","wait","_error$response","_error$response$data","_error$data","specificMessage","includes","code","className","children","_jsxFileName","lineNumber","columnNumber","onSubmit","htmlFor","disabled","type","accept","id","onChange","_c","$RefreshReg$"],"sources":["/home/pranav/Documents/Blockchain-Project/Blockchain-Project/Blockchain-Project/t/client/src/components/FileUpload.js"],"sourcesContent":["import { useState } from \"react\";\nimport axios from \"axios\";\nimport \"./FileUpload.css\";\nimport { toast } from \"react-toastify\";\n\nconst calculateFileHash = async (file) => {\n  const buffer = await file.arrayBuffer();\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n  return hashHex;\n};\n\nconst PINATA_API_KEY = \"ae1ba446a9aeca73624c\";\nconst PINATA_SECRET_API_KEY =\n  \"b30349d6044ed59285ba496207015af363c7ad38dcefdca17fa96481b9f9360d\";\n\nconst CONSENSUS_THRESHOLD = 0.5;\nconst NODE_REQUEST_TIMEOUT = 15000;\n\nconst DEEPFAKE_NODE_URLS = [\n  \"http://localhost:5001/predict\",\n  \"http://localhost:5002/predict\",\n  \"http://localhost:5003/predict\",\n];\n\nconst FileUpload = ({ contract, account, provider }) => {\n  const [file, setFile] = useState(null);\n  const [fileName, setFileName] = useState(\"No image selected\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [message, setMessage] = useState(\"\");\n  const [imageHash, setImageHash] = useState(\"\");\n\n  const retrieveFile = (e) => {\n    const selected = e.target.files[0];\n    if (selected) {\n      setFile(selected);\n      setFileName(selected.name);\n      setMessage(\"\");\n      setImageHash(\"\");\n      toast.success(\"Image/Video file is selected\");\n    } else {\n      setFile(null);\n      setFileName(\"No image selected\");\n      setImageHash(\"\");\n    }\n  };\n\n  const determineConsensus = (results) => {\n    if (!results || results.length === 0) {\n      return {\n        consensus: \"inconclusive\",\n        reason: \"No valid responses from nodes.\",\n      };\n    }\n\n    let realVotes = 0;\n    let fakeVotes = 0;\n    let totalConfidenceReal = 0;\n    let totalConfidenceFake = 0;\n\n    results.forEach((result) => {\n      if (result.is_deepfake === true) {\n        fakeVotes++;\n        totalConfidenceFake +=\n          typeof result.confidence === \"number\" ? result.confidence : 0;\n      } else if (result.is_deepfake === false) {\n        realVotes++;\n        totalConfidenceReal +=\n          typeof result.confidence === \"number\" ? result.confidence : 0;\n      }\n    });\n\n    const totalVotes = realVotes + fakeVotes;\n\n    if (totalVotes === 0) {\n      return {\n        consensus: \"inconclusive\",\n        reason: \"No nodes provided a clear real/fake vote.\",\n      };\n    }\n\n    const realRatio = realVotes / totalVotes;\n    const fakeRatio = fakeVotes / totalVotes;\n\n    console.log(\n      `Consensus Check: Real Votes=${realVotes}, Fake Votes=${fakeVotes}, Total Votes=${totalVotes}, totalConfidenceReal=${totalConfidenceReal}, totalConfidenceFake=${totalConfidenceFake}`\n    );\n\n    if (realRatio > CONSENSUS_THRESHOLD) {\n      const avgConfidence = realVotes > 0 ? totalConfidenceReal / realVotes : 0;\n      return {\n        consensus: \"real\",\n        confidence: avgConfidence,\n        votes: `${realVotes}/${totalVotes}`,\n      };\n    } else if (fakeRatio > CONSENSUS_THRESHOLD) {\n      const avgConfidence = fakeVotes > 0 ? totalConfidenceFake / fakeVotes : 0;\n      return {\n        consensus: \"deepfake\",\n        confidence: avgConfidence,\n        votes: `${fakeVotes}/${totalVotes}`,\n      };\n    } else {\n      // Handle ties or below-threshold majority\n      return {\n        consensus: \"inconclusive\",\n        reason: `No clear majority (${realVotes} real, ${fakeVotes} fake).`,\n      };\n    }\n  };\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (!file) {\n      setMessage(\"Please select a file first.\");\n      return;\n    }\n    if (!contract || !account) {\n      setMessage(\"Wallet not connected or contract not loaded.\");\n      return;\n    }\n\n    setIsLoading(true);\n    setMessage(\"Processing image...\");\n    setImageHash(\"\");\n\n    try {\n      setMessage(\"Calculating image hash...\");\n      const calculatedHash = await calculateFileHash(file);\n      setImageHash(calculatedHash);\n      console.log(\"Calculated Image Hash:\", calculatedHash);\n      toast.success(\"Calculated Image Hash:\", calculatedHash);\n      setMessage(\"Image hash calculated. Analyzing for deepfakes...\");\n\n      const deepfakeFormData = new FormData();\n      deepfakeFormData.append(\"image\", file);\n\n      const promises = DEEPFAKE_NODE_URLS.map((url) => {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(\n          () => controller.abort(),\n          NODE_REQUEST_TIMEOUT\n        );\n\n        return fetch(url, {\n          method: \"POST\",\n          body: deepfakeFormData, // Send the same data\n          signal: controller.signal, // Link abort controller\n        })\n          .then(async (response) => {\n            clearTimeout(timeoutId); // Clear timeout if fetch completes\n            if (!response.ok) {\n              // Try to get error details from response body\n              let errorMsg = `Node request failed: ${response.status}`;\n              try {\n                const errData = await response.json();\n                errorMsg = errData.error || errorMsg;\n              } catch (parseErr) {\n                /* Ignore parsing error */\n              }\n              // Throw an error object compatible with allSettled 'reason'\n              throw new Error(errorMsg);\n            }\n            return response.json(); // Parse successful response\n          })\n          .catch((error) => {\n            clearTimeout(timeoutId); // Clear timeout if fetch fails/aborts\n            console.warn(`Node request failed for ${url}: ${error.message}`);\n            // Return a specific structure for failed promises if needed later,\n            // but allSettled captures the reason object anyway.\n            throw error; // Re-throw to be caught by allSettled as 'rejected'\n          });\n      });\n\n      setMessage(\n        `Sent requests to ${DEEPFAKE_NODE_URLS.length} nodes. Awaiting responses...`\n      );\n      const results = await Promise.allSettled(promises);\n\n      // Process results from nodes that succeeded\n      const successfulResults = [];\n      let nodeErrors = 0;\n      results.forEach((result, index) => {\n        if (result.status === \"fulfilled\") {\n          console.log(\n            `Node ${DEEPFAKE_NODE_URLS[index]} Result:`,\n            result.value\n          );\n          // Basic validation of the result structure\n          if (typeof result.value?.is_deepfake === \"boolean\") {\n            successfulResults.push(result.value);\n          } else {\n            console.warn(\n              `Node ${DEEPFAKE_NODE_URLS[index]} returned invalid data format.`\n            );\n            nodeErrors++;\n          }\n        } else {\n          console.error(\n            `Node ${DEEPFAKE_NODE_URLS[index]} Failed:`,\n            result.reason?.message || result.reason\n          );\n          nodeErrors++;\n        }\n      });\n\n      setMessage(\n        `Received responses. ${successfulResults.length} successful, ${nodeErrors} failed/invalid. Determining consensus...`\n      );\n\n      // --- Step 3: Determine Consensus Outcome ---\n      const consensusOutcome = determineConsensus(successfulResults);\n      console.log(\"Consensus Outcome:\", consensusOutcome);\n\n      // --- Step 4: Act based on Consensus ---\n      if (consensusOutcome.consensus === \"deepfake\") {\n        setMessage(\n          `‚ö†Ô∏è Consensus: Deepfake Detected (${\n            consensusOutcome.votes\n          } votes, avg conf ${consensusOutcome.confidence?.toFixed(\n            4\n          )}). Upload cancelled. Hash: ${calculatedHash.substring(0, 10)}...`\n        );\n        toast.warn(\"DeepFake detected!\");\n        setFile(null);\n        setFileName(\"No image selected\");\n        setIsLoading(false);\n        return;\n      }\n\n      if (consensusOutcome.consensus === \"inconclusive\") {\n        setMessage(\n          `ü§î Consensus Inconclusive: ${consensusOutcome.reason}. Upload cancelled.`\n        );\n        setFile(null);\n        setFileName(\"No image selected\");\n        setIsLoading(false);\n        return;\n      }\n\n      // --- Step 5: Proceed if Consensus is REAL ---\n      setMessage(\n        `‚úÖ Consensus: Real Image Detected (${\n          consensusOutcome.votes\n        } votes, avg conf ${consensusOutcome.confidence?.toFixed(\n          4\n        )}). Uploading to IPFS...`\n      );\n      toast.success(\"Real Image Detected!\");\n\n      // --- Step 6: Upload to Pinata (Same as before) ---\n      const pinataFormData = new FormData();\n      pinataFormData.append(\"file\", file);\n      const pinataMetadata = JSON.stringify({\n        name: fileName,\n        keyvalues: { imageHash: calculatedHash },\n      });\n      pinataFormData.append(\"pinataMetadata\", pinataMetadata);\n      const pinataOptions = JSON.stringify({ cidVersion: 1 });\n      pinataFormData.append(\"pinataOptions\", pinataOptions);\n\n      const resFile = await axios.post(\n        \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n        pinataFormData,\n        {\n          headers: {\n            pinata_api_key: PINATA_API_KEY,\n            pinata_secret_api_key: PINATA_SECRET_API_KEY,\n          },\n        }\n      );\n      const imageCid = resFile.data.IpfsHash;\n      console.log(\"File uploaded to Pinata. CID:\", imageCid);\n\n      if (!imageCid)\n        throw new Error(\"Failed to get IPFS hash from Pinata response.\"); \n\n      setMessage(\n        `Image uploaded to IPFS (CID: ${imageCid.substring(\n          0,\n          10\n        )}...). Adding to blockchain...`\n      );\n      toast.success(\"Image Uploaded to Pinata!\");\n\n      // --- Step 7: Add CID and Hash to Blockchain (Same as before) ---\n      console.log(\n        `Calling contract.add(\"${account}\", \"${imageCid}\", \"${calculatedHash}\")`\n      );\n      const transaction = await contract.add(account, imageCid, calculatedHash);\n      setMessage(\n        `Transaction sent (${transaction.hash.substring(\n          0,\n          10\n        )}...). Waiting for confirmation...`\n      );\n      await transaction.wait();\n\n      setMessage(\n        `‚úÖ Successfully uploaded. CID and Hash recorded on the blockchain!`\n      );\n      toast.success(\"Successfully uploaded. CID and Hash recorded on the blockchain!\");\n      setFileName(\"No image selected\");\n      setFile(null);\n    } catch (error) {\n      console.error(\"Upload process failed:\", error);\n      toast.error(\"Upload process failed:\", error);\n      // More specific error handling might be needed depending on where the error originated\n      let specificMessage = `Upload failed: ${error.message}`;\n      if (error.message.includes(\"Node request failed\")) {\n        specificMessage = `Node verification error: ${error.message}`;\n      } else if (error.response?.data?.error) {\n        specificMessage = `Pinata upload error: ${error.response.data.error}`;\n      } else if (error.code === \"ACTION_REJECTED\") {\n        specificMessage = \"Transaction rejected in MetaMask.\";\n      } else if (error.reason || error.data?.message) {\n        specificMessage = `Blockchain transaction failed: ${\n          error.reason || error.data.message\n        }`;\n      }\n      setMessage(`‚ùå ${specificMessage}`);\n      // Consider leaving file selected on certain errors to allow retry?\n      // setFile(null); setFileName(\"No image selected\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"top file-upload-container\">\n      <h3>Upload & Authenticate Image</h3>\n      <form className=\"form\" onSubmit={handleSubmit}>\n        <label\n          htmlFor=\"file-upload\"\n          className={`choose ${!account || isLoading ? \"disabled\" : \"\"}`}\n        >\n          {file ? \"Change Image\" : \"Choose Image\"}\n        </label>\n        <input\n          disabled={!account || isLoading}\n          type=\"file\"\n          accept=\"image/png, image/jpeg, image/jpg\"\n          id=\"file-upload\"\n          name=\"data\"\n          onChange={retrieveFile}\n        />\n        <span className=\"textArea file-name-display\">Image: {fileName}</span>\n        <button\n          type=\"submit\"\n          className=\"upload\"\n          disabled={!file || isLoading || !account}\n        >\n          {isLoading ? \"Processing...\" : \"Verify & Upload\"}\n        </button>\n      </form>\n      {message && (\n        <p\n          className={`upload-message ${\n            message.includes(\"Error\") ||\n            message.includes(\"‚ö†Ô∏è\") ||\n            message.includes(\"‚ùå\") ||\n            message.includes(\"ü§î\")\n              ? \"error\"\n              : message.includes(\"‚úÖ\")\n              ? \"success\"\n              : \"info\"\n          }`}\n        >\n          {message}\n        </p>\n      )}\n    </div>\n  );\n};\n\nexport default FileUpload;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}